BUMP SABER blocks
-----------------

Four SABER blocks are based on BUMP:

* **BUMP_NICAS**: grid-point smoother for correlation or localization.
* **BUMP_StdDev**: standard-deviation (diagonal) operator.
* **BUMP_VerticalBalance**: vertical balance operator.
* **BUMP_PsiChiToUV**: variable change from streamfunction and velocity potential to horizontal wind components, using smooth estimates of the derivatives.

BUMP_NICAS SABER block
**********************

BUMP_NICAS is a central SABER block that calls NICAS (Normalized Interpolated Convolution on an Adaptive Subgrid) smoother for correlation or localization operators.

NICAS calibration
^^^^^^^^^^^^^^^^^

The localization (for ensemble covariance) or correlation (for parametric covariance) operator generated by the NICAS driver can be set up with horizontal and vertical length-scales explicitly specified in the yaml. The lengthscales should be specified as Gaspari-Cohn support radii. For a comparison with the closest Gaussian function, this support should be equal to 3.57 sigma (empirical value found from best fit). An example of yaml for BUMP_NICAS using explicit length-scales:

  .. code-block:: yaml

   saber block name: BUMP_NICAS
   calibration:
     io:
       data directory: path_to_bump_directory  # BUMP data directory
       files prefix: my_bump_files             # BUMP files prefix
     drivers:
       multivariate strategy: univariate  # NICAS multivariate strategy (here: same localization for all variables)
       compute nicas: true                # Run NICAS driver
       write global nicas: true           # Write global NICAS files
       write local nicas: true            # Write local NICAS files
     nicas:
       resolution: 8                      # NICAS subgrid resolution
       explicit length-scales: true
       horizontal length-scale:
       - groups: [var1]
         value: 1000.0e+3          # Horizontal lengthscale (in m), single value for var_1
       vertical length-scale:
       - groups: [var1]
         value: 0.5                # Vertical lengthscale (in vertical units of model's choice)

The explicit horizontal lengthscales can be specified either as a single value or as a profile (one value for each vertical level), e.g.:

  .. code-block:: yaml

     nicas:
       resolution: 8                      # NICAS subgrid resolution
       explicit length-scales: true
       horizontal length-scale:
       - groups: [var1]
         profile:      # for three vertical levels
         - 1000.0e+3
         - 1500.0e+3
         - 2000.0e+3

Vertical correlations depend on the vertical coordinate provided by the model interfaced to SABER. The models pass vertical coordinate to BUMP as the field `vert coordinate` in extra Geometry fields.
If vertical lengthscale is not specified in the yaml, it is assumed to be zero. Note that if vertical lengthscale is set to zero the convolution will only be computed between the grid points that have the same vertical coordinate.

An important parameter in the :code:`nicas` subsection is the :code:`resolution`. It is a unitless real number, and it can be understood as the number of points that would be used in a 1D case to discretize the Gaspari-Cohn function from its origin to the limit of its support. The function representation is more precise with a larger resolution. It is recommended to use resolution of at least 3, better (if affordable computationally) 4-8.

Note that the computational and memory cost of NICAS depends on the :code:`resolution` and on the lengthscale: the higher the resolution, and the smaller the correlation lengthscale, the more computationally expensive NICAS estimation is. Resolution and lengthscale define the number of horizontal grid points used in NICAS, and the impact of resolution on the number of horizontal grid points is quadratic. Since the computational cost grows with the number of horizontal grid points, NICAS sets an upper bound on the number of horizontal grid points to avoid significantly costly computations. This upper bound can be overridden using a yaml parameter :code:`max horizontal grid size` in the nicas subsection. If the theoretical horizontal grid size (estimated from specified resolution and lengthscales) exceeds max horizontal grid size, then a lower effective resolution is computed and printed in the log. If effective resolution is lower than 3, the code will abort and the user will need to either reduce the resolution or increase max horizontal grid size. Note that the code for generating NICAS coefficients may run significantly slower for large :code:`max horizontal grid size`, but once NICAS coefficients are estimated, their application is fast.

In general, NICAS smoother is very efficient for large length-scales, which is the case for localization length-scales in general, but can be inefficent for small length-scales.

Correlation and localization length scales for BUMP can also be diagnosed from the ensemble using BUMP HDIAG (Hybrid DIAGnostics) driver, e.g. for estimating localization lengthscales from the ensemble:

  .. code-block:: yaml

    saber block name: BUMP_NICAS
    calibration:
      io:
        data directory: path_to_bump_directory  # BUMP data directory
        files prefix: my_bump_files             # BUMP files prefix
      drivers:
        multivariate strategy: univariate  # NICAS multivariate strategy (here: same localization for all variables)
        compute covariance: true
        compute correlation: true
        compute localization: true
        compute nicas: true
        write global nicas: true
        write local nicas: true
      sampling:
        distance class width: 500.0e3         # Distance class size (in m) in HDIAG
        computation grid size: 500            # Number of subsampling points in HDIAG
        distance classes: 20                  # Number of distance classes in HDIAG
        reduced levels: 2                     # Number of reduced levels in HDIAG
      nicas:
        resolution: 8.0                       # NICAS subgrid resolution

And for estimating correlation lengths-scales from the ensemble:

  .. code-block:: yaml

    saber block name: BUMP_NICAS
    calibration:
      io:
        data directory: path_to_bump_directory  # BUMP data directory
        files prefix: my_bump_files             # BUMP files prefix
      drivers:
        multivariate strategy: univariate  # NICAS multivariate strategy (here: same localization for all variables)
        compute covariance: true
        compute correlation: true
        compute nicas: true
        write global nicas: true
        write local nicas: true
      sampling:
        distance class width: 500.0e3         # Distance class size (in m) in HDIAG
        computation grid size: 500            # Number of subsampling points in HDIAG
        distance classes: 20                  # Number of distance classes in HDIAG
        reduced levels: 2                     # Number of reduced levels in HDIAG
      nicas:
        resolution: 8.0                       # NICAS subgrid resolution


Pre-computed NICAS use
^^^^^^^^^^^^^^^^^^^^^^

NICAS can be computed on the fly and used as in previous section, or pre-computed as in the previous section, and applied within SABER blocks, e.g.:

  .. code-block:: yaml

    saber block name: BUMP_NICAS
    read:
      io:
        data directory: path_to_bump_directory  # BUMP data directory
        prefix: my_bump_files                   # BUMP files prefix
      drivers:
        multivariate strategy: univariate
        read local nicas: true                  # Load local NICAS data

Note that for some operators like NICAS, BUMP can produce "local" files (one per MPI task) or "global" files (a single file) during the NICAS computation described in the previous section. If local files were produced when generating NICAS files, the application using those files has to be run with the same number of MPI tasks and the same grid distribution among these tasks.

To use global NICAS files, use :code:`read global nicas` instead of :code:`read local nicas`.

BUMP_StdDev SABER block
***********************

BUMP_StdDev is the standard-deviation (diagonal) operator. Standard deviations can be estimated from the ensemble and filtered, e.g.:

    .. code-block:: yaml

      saber block name: BUMP_StdDev
      calibration:
        io:
          data directory: path_to_bump_directory            # BUMP data directory
          files prefix: my_bump_files                       # BUMP files prefix
        drivers:
          compute variance: true
        variance:
          objective filtering: true
          filtering iterations: 3
          initial length-scale:
          - variables:
            - stream_function
            value: 3000.0e3
        output model files:
        - parameter: stddev
          file:
            <...>                 # model-specific output files with std dev


Note that unlike in BUMP_NICAS output, BUMP_StdDev can output standard deviation files on the model grid in the files specified in :code:`output model files` yaml section. To use pre-computed standard deviations, one can use:

  .. code-block:: yaml

    saber block name: BUMP_StdDev
    read:
      model file:
        <...>         # model-specific file with std dev generated by BUMP

BUMP_VerticalBalance SABER block
********************************

BUMP_VerticalBalance is an outer SABER block that implements vertical balance operator. An example of estimating the vertical balance from an ensemble:

    .. code-block:: yaml

      saber block name: BUMP_VerticalBalance
      calibration:
        io:
          data directory: path_to_bump_directory            # BUMP data directory
          files prefix: my_bump_files                       # BUMP files prefix
        drivers:
          compute vertical balance: true                    # Run VBAL driver
          compute vertical covariance: true
          write vertical balance: true
          write vertical covariance: true
        sampling:
          computation grid size: 500
          diagnostic grid size: 200
          grid type: octahedral
          averaging length-scale: 2000.0e3
        vertical balance:
          vbal:
          - balanced variable: velocity_potential
            unbalanced variable: stream_function
          - balanced variable: air_temperature
            unbalanced variable: stream_function
          - balanced variable: surface_pressure
            unbalanced variable: stream_function
          pseudo inverse: true

An example of application of the pre-computed vertical balance:


  .. code-block:: yaml

    saber block name: BUMP_VerticalBalance
    read:
      io:
        data directory: path_to_bump_directory     # BUMP data directory
        files prefix: my_bump_files                # BUMP files prefix
      drivers:
        read local sampling: true
        read vertical balance: true
      vertical balance:
        vbal:
        - balanced variable: velocity_potential
          unbalanced variable: stream_function
        - balanced variable: air_temperature
          unbalanced variable: stream_function
        - balanced variable: surface_pressure
          unbalanced variable: stream_function


BUMP_PsiChiToUV SABER block
***************************

BUMP_PsiChiToUV is an outer SABER block implementing horizontal wind variable change. For the streamfunction/velocity potential to horizonal winds variable change one can use the following yaml to compute and save the local files:

    .. code-block:: yaml

      saber block name: BUMP_PsiChiToUV
      calibration:
        io:
          data directory: path_to_bump_directory  # BUMP data directory
          files prefix: my_bump_files             # BUMP files prefix
        drivers:
          compute psichitouv: true
          write local psichitouv: true
        psichitouv:
          longitudes: 400       # Number of longitudes for the internal calculation grid
          latitudes: 200        # Number of latitudes for the internal calculation grid
          savitzky-golay half width: 5 # Number of points for the Savitzky-Golay filter (to estimate smooth derivatives)
          wind inflation: 1.1   # Wind inflation to compensate for the smoothing

To apply pre-computed transform, the following yaml can be used:

  .. code-block:: yaml

    saber block name: BUMP_PsiChiToUV
    read:
      io:
        data directory: path_to_bump_directory  # BUMP data directory
        files prefix: my_bump_files             # BUMP files prefix
      drivers:
        read local psichitouv: true

